<h1 style="text-align:center">SB3 MP1 Report</h1>

## In your writeup, describe your experiences in practicing controlling the quad.

We found that flying the drone wasn't too hard, but rather, the hardware was the most problematic part of controlling the quadcopter. Trying to learn how to fly the drone with multiple quadcopters that had broken motors or battery problems turned out to be quite a task. Even at max throttle, most batteries we used couldn't lift the drone off the ground. It also took us too long of a time to realize that the trim of our right joystick was too high, preventing us from moving backward or keeping the drone stable.

## In your writeup, describe the PPM signals. What do each of the channels correspond to, and what are their minimum and maximum ranges? What is the total length of the individual PPM frames, and what is the minimum length of the idle pulse?


We were able to probe the HK-T6A controller with the Picoscope. Analysing the PPM wave form generated by the controller, we inferred the following;

![ppm_on_pico](report_assets/PPM_ex.PNG)

From this observation, we measured the channels, interchannels, and overall frame. In general, we found that the interchannels were consistantly around 400 us, the overall frame was roughly 20 ms, and each channel had a maximum pulse width of about 1.1 ms and a minumum pulse width of about 600 us. With all channels set to their maximum width, we would see an minumum idle pulse of 11 ms. 


## Based on the ZedBoard documentation and your oscilloscope measurement of the trainer port, what concerns do you have about making this connection?

TODO: Were there any other major issues?

The only real issue was VCC mismatch between the two systems - the HA-T6A controller had a 5V VCC but the Zedboard had a 3.3V VCC. To avoid frying the Zedboard, we were provided a Sparkfun Logic Level Converter which down stepped from 5V to 3.3V and upstepped from 3.3V to 5V. 

## In your write up, provide a structural diagram of the axi_ppm design, from the top-level AMBA AXI interface down to where you user logic will reside. 

Attached below is a figure that represents the structure of our custom AMBA AXI4-Lite IP for the axi_ppm design for sub-section A. At the highest level, we instantiated our RTL for our PPM capture and generate FSMs. We also created probes that were accessible by ILAs on the main design. However, it should be noted that the probes were removed once the AXI was functioning as expected. Additional signals were used to connect the FSM outputs and inputs to the AXI slave instatiation. In the slave, FSM inputs are relayed to their respective slave registers, which in turn are configured to be accessed by software. An additional mux was described to switch between software and hardware relay modes. 

It should be noted that sub-section B deviated in this design by instantiating their PPM capture and generate FSMs in the slave instatiation instead of at the top level. In hindsight, we believe this was the better approach as it eliminated the need for excess signals at the top level. 

![axi_ppm_top](report_assets/AXI.png)

## How does an address on the AMBA bus generate a read or write enable signal for the slave registers in your design, and how will your PPM state machine get access to the IP coreâ€™s Memory Mapped registers?

TODO: Do we want to go into specifics regarding the things we changed in the slave AXI to enable read and write for slv_reg?

The AMBA AXI IP is connected to the Zynq processor on the main design through an AXI interconnect. This connection allows for a base address to be mapped for the IP which enables software access to the 16 slave registers (slv_reg) instantiated in the slave AXI. In order to access the individual slave registers, we had to introduce an appropriate offset to the address. In our case, it was + 0x4 per register. We believed this to be the case as the slave register sizes were set to 32 bits, or 4 bytes. So, for our design, since the base address for the AXI IP was 0x43C00000, our subsequent registers were mapped as such;

 slv_reg0 = 0x43C00000 \
 slv_reg1 = 0x43C00004 \
 slv_reg2 = 0x43C00008 \
 ... \
 slv_regX = 0x43C00000 + (4 * X)

Our system was designed such that the software reads a done signal from the PPM capture and generate FSM 

## Starting from the generic FSMs in your HW-1 write-up, update the User Logic module such that the design can appropriately capture and generate PPM values for the Hobby King 6ch transmitter as described above.

TODO: Add stuff for generate PPM, I also think we should include all of our FSMs since they seem pretty different

### Sub-section A:
Capture PPM - 
TODO: elaborate

![sub_a_capture_fsm](report_assets/PPM_capture_FSM_trim.png)

