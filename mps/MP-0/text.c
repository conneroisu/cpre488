#include <ctype.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#define GAME_MENU_POS 1
#define GAME_MENU_ROWS 10

#define VIDEO_WIDTH 640
#define VIDEO_HEIGHT 480

#define FONT_WIDTH 8
#define FONT_HEIGHT 8

typedef uint16_t u16;
typedef uint8_t u8;

// The framebuffer: 16-bit pixels with the following layout:
// Bits [15:12] = Blue, [11:8] = Green, [7:4] = Red, [3:0] = Unused.
u16 framebuffer[VIDEO_HEIGHT][VIDEO_WIDTH];

typedef struct {
  const char *title;
  int year_released;
  const char *genre;
} Game;

Game games[] = {
    {"Adventure Island II", 1991, "Platformer/Action"},
    {"Bad Dudes", 1988, "Beat ‘em up"},
    {"Balloon Fight", 1984, "Arcade/Action"},
    {"Batman - The Video Game", 1989, "Action/Platformer"},
    {"Battle of Olympus", 1988, "Action/Platformer"},
    {"Battletoads - Double Dragon", 1993, "Beat ‘em up"},
    {"Bionic Commando", 1988, "Action/Platformer"},
    {"Blades of Steel", 1988, "Sports (Ice Hockey)"},
    {"Bomberman", 1983, "Maze/Action"},
    {"Bombermen", 1990, "Action/Puzzle"},
    {"Bubble Bobble", 1986, "Platform/Puzzle"},
    {"Bucky O'Hare", 1992, "Platformer"},
    {"BurgerTime", 1982, "Arcade/Action"},
    {"Cabal", 1988, "Run and Gun"},
    {"Captain Skyhawk", 1990, "Shooter (Horizontal scrolling)"},
    {"Castlevania", 1986, "Action-Adventure/Platformer"},
    {"Castlevania II - Simon's Quest", 1987, "Action-Adventure"},
    {"Circus Caper", 1988, "Platformer"},
    {"Clash at Demonhead", 1989, "Platformer"},
    {"Cobra Triangle", 1989, "Action/Arcade"},
    {"Commando", 1985, "Run and Gun"},
    {"Contra", 1987, "Run and Gun"},
    {"Contra Force", 1992, "Run and Gun"},
    {"Coop-Super Mario Bros", 1991, "Platformer (Cooperative play)"},
    {"Crystalis", 1990, "Action RPG"},
    {"Darkwing Duck", 1992, "Platformer"},
    {"Die Hard", 1989, "Action"},
    {"Donkey Kong", 1981, "Arcade/Platform"},
    {"Donkey Kong Jr", 1982, "Arcade/Platform"},
    {"Double Dragon", 1987, "Beat ‘em up"},
    {"Double Dragon II", 1988, "Beat ‘em up"},
    {"Double Dribble", 1986, "Sports (Basketball)"},
    {"Dragon Spirit", 1989, "Shooter"},
    {"DuckTales", 1989, "Platformer"},
    {"Elevator Action", 1983, "Stealth/Action"},
    {"Excitebike", 1984, "Racing"},
    {"Faxanadu", 1987, "Action RPG/Platformer"},
    {"Felix the Cat", 1992, "Platformer"},
    {"Fire 'n Ice", 1992, "Action/Platformer"},
    {"G.I. Joe - A Real American Hero", 1985, "Action/Run and Gun"},
    {"Galaxy 5000 - Racing in the 51st Century", 1988, "Racing"},
    {"Gargoyle's Quest II", 1992, "Action-Adventure/RPG"},
    {"Ghosts 'n Goblins", 1985, "Platformer"},
    {"Guerrilla War", 1987, "Beat ‘em up"},
    {"Gun.Smoke", 1985, "Run and Gun"},
    {"Gun Nac", 1990, "Shoot ‘em up"},
    {"Hogan's Alley", 1984, "Light Gun Shooter"},
    {"Ice Climber", 1985, "Platformer"},
    {"Ice Hockey", 1991, "Sports"},
    {"Indiana Jones and the Last Crusade", 1989, "Action-Adventure"},
    {"Jackal", 1986, "Run and Gun"},
    {"Journey to Silius", 1990, "Run and Gun"},
    {"KickMaster", 1990, "Platformer/Fighting"},
    {"Kid Icarus", 1986, "Action-Platformer"},
    {"Kirby's Adventure", 1993, "Platformer"},
    {"Lemmings", 1991, "Puzzle"},
    {"Life Force", 1986, "Shooter"},
    {"Little Nemo - The Dream Master", 1990, "Platformer"},
    {"Little Samson", 1992, "Platformer"},
    {"Lode Runner", 1983, "Puzzle/Platform"},
    {"Maniac Mansion", 1987, "Graphic Adventure"},
    {"Marble Madness", 1984, "Puzzle/Arcade"},
    {"Mega Man", 1987, "Action-Platformer"},
    {"Mega Man 2", 1988, "Action-Platformer"},
    {"Mega Man 3", 1990, "Action-Platformer"},
    {"Mega Man 4", 1991, "Action-Platformer"},
    {"Mega Man 5", 1992, "Action-Platformer"},
    {"Mega Man 6", 1993, "Action-Platformer"},
    {"Metroid", 1986, "Action-Adventure"},
    {"Mighty Final Fight", 1993, "Beat ‘em up"},
    {"Ms. Pac-Man", 1982, "Arcade"},
    {"Ninja Crusaders", 1992, "Action/Beat ‘em up"},
    {"North and South", 1989, "Strategy"},
    {"Paperboy", 1985, "Action/Simulation"},
    {"Popeye", 1982, "Action/Arcade"},
    {"Power Blade", 1990, "Action/Platform"},
    {"Prince of Persia", 1989, "Action-Adventure/Platformer"},
    {"Princess Tomato in the Salad Kingdom", 1989, "Platformer"},
    {"Pro Wrestling", 1986, "Sports/Fighting"},
    {"R.C. Pro-Am", 1988, "Racing"},
    {"RBI Baseball", 1988, "Sports"},
    {"Rad Racer", 1987, "Racing"},
    {"Rampage", 1986, "Action"},
    {"River City Ransom", 1989, "Beat ‘em up with RPG elements"},
    {"Robin Hood - Prince of Thieves", 1991, "Action/Platformer"},
    {"Rollergames", 1991, "Sports"},
    {"Rygar", 1986, "Action-Adventure"},
    {"S.C.A.T. - Special Cybernetic Attack Team", 1992, "Run and Gun"},
    {"Shadow of the Ninja", 1990, "Beat ‘em up"},
    {"Shadowgate", 1987, "Adventure/Puzzle"},
    {"Shatterhand", 1991, "Beat ‘em up/Platformer"},
    {"Strider", 1989, "Action/Platformer"},
    {"Super Dodge Ball", 1991, "Sports"},
    {"Super Mario Bros", 1985, "Platformer"},
    {"Super Mario Bros 2", 1988, "Platformer"},
    {"Super Mario Bros 3", 1990, "Platformer"},
    {"Super Pitfall", 1992, "Platformer"},
    {"Super Spike V Ball", 1990, "Sports"},
    {"Tecmo Super Bowl", 1991, "Sports"},
    {"Tecmo World Wrestling", 1991, "Sports/Fighting"},
    {"Teenage Mutant Ninja Turtles - Tournament Fighters", 1993, "Fighting"},
    {"Teenage Mutant Ninja Turtles II", 1991, "Beat ‘em up"},
    {"Teenage Mutant Ninja Turtles III", 1992, "Beat ‘em up"},
    {"Tetris", 1984, "Puzzle"},
    {"Tetris 2", 1990, "Puzzle"},
    {"The Flintstones - The Rescue of Dino & Hoppy", 1991, "Platformer"},
    {"The Guardian Legend", 1988, "Action-Adventure/Shooter"},
    {"The Legend of Kage", 1985, "Action/Stealth"},
    {"The Legend of Zelda", 1986, "Action-Adventure"},
    {"The Little Mermaid", 1991, "Platformer"},
    {"The Magic of Scheherazade", 1992, "Puzzle/Adventure"},
    {"Tiny Toon Adventures", 1992, "Platformer"},
    {"Top Gun", 1987, "Flight Simulator/Action"},
    {"Track & Field", 1983, "Sports"},
    {"Vice - Project Doom", 1991, "Action/Platformer"},
    {"Wizards & Warriors", 1987, "Action-Adventure"},
    {"Zelda II - The Adventure of Link", 1987, "Action-Adventure/RPG"}};

/*
 * Complete 8x8 font table for the first 128 ASCII characters.
 * Data derived from the public domain font8x8_basic.
 */
static const u8 font8x8_basic[128][8] = {
    [0x00] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x01] = {0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E},
    [0x02] = {0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E},
    [0x03] = {0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00},
    [0x04] = {0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00},
    [0x05] = {0x00, 0x18, 0x3C, 0x7E, 0x3C, 0x18, 0x00, 0x00},
    [0x06] = {0xFF, 0xE7, 0xC3, 0x81, 0xC3, 0xE7, 0xFF, 0x00},
    [0x07] = {0x00, 0x66, 0xFF, 0xFF, 0xFF, 0x6E, 0x3C, 0x00},
    [0x08] = {0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00},
    [0x09] = {0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x0A] = {0x18, 0x3C, 0x7E, 0xFF, 0x7E, 0x3C, 0x18, 0x00},
    [0x0B] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
    [0x0C] = {0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x18, 0x00},
    [0x0D] = {0xFF, 0xDB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
    [0x0E] = {0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
    [0x0F] = {0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
    [0x10] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x11] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x12] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x13] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x14] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x15] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x17] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x18] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x19] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x1A] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x1B] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x1C] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x1D] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x1E] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    [0x1F] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // Printable characters (0x20 to 0x7E)
    [0x20] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // space
    [0x21] = {0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00}, // !
    [0x22] = {0x6C, 0x6C, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00}, // "
    [0x23] = {0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00}, // #
    [0x24] = {0x18, 0x3E, 0x58, 0x3C, 0x1A, 0x7C, 0x18, 0x00}, // $
    [0x25] = {0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00}, // %
    [0x26] = {0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00}, // &
    [0x27] = {0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00}, // '
    [0x28] = {0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00}, // (
    [0x29] = {0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00}, // )
    [0x2A] = {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00}, // *
    [0x2B] = {0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00}, // +
    [0x2C] = {0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00}, // ,
    [0x2D] = {0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00}, // -
    [0x2E] = {0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00}, // .
    [0x2F] = {0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00}, // /
    [0x30] = {0x7C, 0xC6, 0xCE, 0xD6, 0xE6, 0xC6, 0x7C, 0x00}, // 0
    [0x31] = {0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00}, // 1
    [0x32] = {0x7C, 0xC6, 0x0E, 0x1C, 0x70, 0xC6, 0xFE, 0x00}, // 2
    [0x33] = {0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00}, // 3
    [0x34] = {0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00}, // 4
    [0x35] = {0xFE, 0xC0, 0xF8, 0x0C, 0x06, 0xC6, 0x7C, 0x00}, // 5
    [0x36] = {0x3C, 0x60, 0xC0, 0xF8, 0xC6, 0xC6, 0x7C, 0x00}, // 6
    [0x37] = {0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00}, // 7
    [0x38] = {0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00}, // 8
    [0x39] = {0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00}, // 9
    [0x3A] = {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00}, // :
    [0x3B] = {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30, 0x00}, // ;
    [0x3C] = {0x0E, 0x1C, 0x38, 0x70, 0x38, 0x1C, 0x0E, 0x00}, // <
    [0x3D] = {0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00}, // =
    [0x3E] = {0x70, 0x38, 0x1C, 0x0E, 0x1C, 0x38, 0x70, 0x00}, // >
    [0x3F] = {0x7C, 0xC6, 0x0E, 0x1C, 0x18, 0x00, 0x18, 0x00}, // ?
    [0x40] = {0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x7C, 0x00}, // @
    [0x41] = {0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00}, // A
    [0x42] = {0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00}, // B
    [0x43] = {0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00}, // C
    [0x44] = {0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00}, // D
    [0x45] = {0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00}, // E
    [0x46] = {0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00}, // F
    [0x47] = {0x3C, 0x66, 0xC0, 0xCE, 0xC6, 0x66, 0x3A, 0x00}, // G
    [0x48] = {0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00}, // H
    [0x49] = {0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, // I
    [0x4A] = {0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00}, // J
    [0x4B] = {0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00}, // K
    [0x4C] = {0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00}, // L
    [0x4D] = {0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00}, // M
    [0x4E] = {0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00}, // N
    [0x4F] = {0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00}, // O
    [0x50] = {0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00}, // P
    [0x51] = {0x78, 0xCC, 0xCC, 0xCC, 0xD8, 0x70, 0xDC, 0x00}, // Q
    [0x52] = {0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00}, // R
    [0x53] = {0x7C, 0xC6, 0xC0, 0x7C, 0x06, 0xC6, 0x7C, 0x00}, // S
    [0x54] = {0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x3C, 0x00}, // T
    [0x55] = {0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00}, // U
    [0x56] = {0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00}, // V
    [0x57] = {0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00}, // W
    [0x58] = {0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00}, // X
    [0x59] = {0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x00}, // Y
    [0x5A] = {0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00}, // Z
    [0x5B] = {0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00}, // [
    [0x5C] = {0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00}, // backslash
    [0x5D] = {0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00}, // ]
    [0x5E] = {0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00}, // ^
    [0x5F] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF}, // _
    [0x60] = {0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00}, // `
    [0x61] = {0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00}, // a
    [0x62] = {0xE0, 0x60, 0x7C, 0x66, 0x66, 0x66, 0xDC, 0x00}, // b
    [0x63] = {0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x00}, // c
    [0x64] = {0x1C, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00}, // d
    [0x65] = {0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00}, // e
    [0x66] = {0x38, 0x6C, 0x60, 0xF8, 0x60, 0x60, 0xF0, 0x00}, // f
    [0x67] = {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8}, // g
    [0x68] = {0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00}, // h
    [0x69] = {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00}, // i
    [0x6A] = {0x0C, 0x00, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78}, // j
    [0x6B] = {0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00}, // k
    [0x6C] = {0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, // l
    [0x6D] = {0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xC6, 0x00}, // m
    [0x6E] = {0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x00}, // n
    [0x6F] = {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00}, // o
    [0x70] = {0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0}, // p
    [0x71] = {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E}, // q
    [0x72] = {0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0xF0, 0x00}, // r
    [0x73] = {0x00, 0x00, 0x7C, 0xC0, 0x7C, 0x06, 0xFC, 0x00}, // s
    [0x74] = {0x30, 0x30, 0xFC, 0x30, 0x30, 0x36, 0x1C, 0x00}, // t
    [0x75] = {0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00}, // u
    [0x76] = {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00}, // v
    [0x77] = {0x00, 0x00, 0xC6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00}, // w
    [0x78] = {0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00}, // x
    [0x79] = {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0xFC}, // y
    [0x7A] = {0x00, 0x00, 0xFE, 0x4C, 0x18, 0x32, 0xFE, 0x00}, // z
    [0x7B] = {0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00}, // {
    [0x7C] = {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00}, // |
    [0x7D] = {0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00}, // }
    [0x7E] = {0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // ~
    [0x7F] = {0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00}  // DEL
};

/*
 * Draw a single character at (x, y) using the given 16-bit color.
 * The character is rendered using the 8x8 font defined above.
 */
void draw_char(int x, int y, char c, u16 color) {
  if ((unsigned char)c > 127)
    return;
  for (int row = 0; row < FONT_HEIGHT; row++) {
    u8 row_bits = font8x8_basic[(unsigned char)c][row];
    for (int col = 0; col < FONT_WIDTH; col++) {
      if (row_bits & (1 << (7 - col))) {
        int px = x + col;
        int py = y + row;
        if (px >= 0 && px < VIDEO_WIDTH && py >= 0 && py < VIDEO_HEIGHT) {
          framebuffer[py][px] = color;
        }
      }
    }
  }
}

/*
 * Draw a null-terminated string starting at (x, y) using the given 16-bit
 * color. The newline character ('\n') moves the cursor to the beginning of the
 * next line.
 */
void draw_text(int x, int y, const char *text, u16 color) {
  int cursor_x = x;
  while (*text) {
    if (*text == '\n') {
      cursor_x = x;
      y += FONT_HEIGHT;
    } else {
      draw_char(cursor_x, y, *text, color);
      cursor_x += FONT_WIDTH;
    }
    text++;
  }
}

/*
 * Helper: Skip whitespace in the file.
 */
static void skip_whitespace(FILE *fp) {
  int ch;
  while ((ch = fgetc(fp)) != EOF && isspace(ch))
    ;
  if (ch != EOF)
    ungetc(ch, fp);
}

/*
 * Load a binary PPM (P6) image.
 * The function reads the header to determine image dimensions,
 * and returns a dynamically allocated buffer with RGB pixel data.
 * Returns NULL on failure.
 */
u8 *load_ppm(const char *filename, int *width, int *height) {
  FILE *fp = fopen(filename, "rb");
  if (!fp) {
    fprintf(stderr, "Error: Could not open PPM file %s\n", filename);
    return NULL;
  }

  char magic[3] = {0};
  if (fscanf(fp, "%2s", magic) != 1 || magic[0] != 'P' || magic[1] != '6') {
    fprintf(stderr, "Error: Not a valid P6 PPM file: %s\n", filename);
    fclose(fp);
    return NULL;
  }

  skip_whitespace(fp);
  int ch = fgetc(fp);
  while (ch == '#') { // skip comment lines
    while ((ch = fgetc(fp)) != '\n' && ch != EOF)
      ;
    skip_whitespace(fp);
    ch = fgetc(fp);
  }
  if (ch != EOF)
    ungetc(ch, fp);

  if (fscanf(fp, "%d %d", width, height) != 2) {
    fprintf(stderr, "Error: Failed to read image dimensions from %s\n",
            filename);
    fclose(fp);
    return NULL;
  }

  int max_val;
  if (fscanf(fp, "%d", &max_val) != 1) {
    fprintf(stderr, "Error: Failed to read max color value from %s\n",
            filename);
    fclose(fp);
    return NULL;
  }
  if (max_val != 255) {
    fprintf(
        stderr,
        "Warning: max color value is not 255 (%d). Conversion may be off.\n",
        max_val);
  }
  fgetc(fp); // consume single whitespace after header

  size_t data_size = 3 * (*width) * (*height);
  u8 *data = malloc(data_size);
  if (!data) {
    fprintf(stderr, "Error: Could not allocate memory for image.\n");
    fclose(fp);
    return NULL;
  }
  if (fread(data, 1, data_size, fp) != data_size) {
    fprintf(stderr, "Error: Could not read image data from %s\n", filename);
    free(data);
    fclose(fp);
    return NULL;
  }
  fclose(fp);
  return data;
}

/*
 * Render a PPM image (converted from PNG externally) into the framebuffer
 * at position (dest_x, dest_y) with scaling.
 *
 * 'scale' is a floating-point factor. For example, scale = 0.5 will reduce
 * the image dimensions by half; scale = 2.0 will double them.
 *
 * A simple nearest-neighbor algorithm is used.
 *
 * Returns 0 on success, non-zero on failure.
 */
int render_ppm_scaled(const char *filename, int dest_x, int dest_y,
                      float scale) {
  int img_width, img_height;
  u8 *img_data = load_ppm(filename, &img_width, &img_height);
  if (!img_data)
    return -1;

  int scaled_width = (int)(img_width * scale);
  int scaled_height = (int)(img_height * scale);

  for (int sy = 0; sy < scaled_height; sy++) {
    int fb_y = dest_y + sy;
    if (fb_y < 0 || fb_y >= VIDEO_HEIGHT)
      continue;
    int orig_y = (int)(sy / scale);
    if (orig_y >= img_height)
      orig_y = img_height - 1;
    for (int sx = 0; sx < scaled_width; sx++) {
      int fb_x = dest_x + sx;
      if (fb_x < 0 || fb_x >= VIDEO_WIDTH)
        continue;
      int orig_x = (int)(sx / scale);
      if (orig_x >= img_width)
        orig_x = img_width - 1;

      // Get the original pixel (RGB, 8 bits each)
      u8 r = img_data[(orig_y * img_width + orig_x) * 3 + 0];
      u8 g = img_data[(orig_y * img_width + orig_x) * 3 + 1];
      u8 b = img_data[(orig_y * img_width + orig_x) * 3 + 2];
      // Convert 8-bit channels to 4-bit (nearest neighbor)
      u8 r4 = r >> 4;
      u8 g4 = g >> 4;
      u8 b4 = b >> 4;
      // Pack into 16-bit pixel: blue in [15:12], green in [11:8], red in [7:4]
      u16 pixel = (b4 << 12) | (g4 << 8) | (r4 << 4);
      framebuffer[fb_y][fb_x] = pixel;
    }
  }
  free(img_data);
  return 0;
}

/*
 * Write the framebuffer to a binary PPM (P6) file.
 * The 16-bit pixel format is converted to 24-bit RGB by scaling each 4-bit
 * channel. Each 4-bit channel is multiplied by 17 to map the 0–15 range to
 * 0–255.
 */
void write_framebuffer_to_ppm(const char *filename) {
  FILE *fp = fopen(filename, "wb");
  if (!fp) {
    fprintf(stderr, "Error: Could not open %s for writing.\n", filename);
    exit(EXIT_FAILURE);
  }

  fprintf(fp, "P6\n%d %d\n255\n", VIDEO_WIDTH, VIDEO_HEIGHT);

  for (int i = 0; i < VIDEO_HEIGHT; i++) {
    for (int j = 0; j < VIDEO_WIDTH; j++) {
      u16 pixel = framebuffer[i][j];
      u8 red = ((pixel >> 4) & 0xF) * 17;
      u8 green = ((pixel >> 8) & 0xF) * 17;
      u8 blue = ((pixel >> 12) & 0xF) * 17;
      fputc(red, fp);
      fputc(green, fp);
      fputc(blue, fp);
    }
  }
  fclose(fp);
  printf("Framebuffer written to %s\n", filename);
}

int main(void) {
  // Clear the framebuffer to white.
  // In our format, 0xFFFF sets each 4-bit color channel to maximum.
  for (int i = 0; i < VIDEO_HEIGHT; i++) {
    for (int j = 0; j < VIDEO_WIDTH; j++) {
      framebuffer[i][j] = 0xFFFF;
    }
  }

  // Draw some sample text in black.
  draw_text(50, 50,
            "Hello, World!\n"
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ\n"
            "abcdefghijklmnopqrstuvwxyz\n"
            "0123456789 !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~",
            0x0000); // 0x0000 is black in our 16-bit format.

  // Render a PPM image (converted from PNG externally) at position (50, 150)
  // with scaling. Adjust the scale factor as needed (e.g., 0.5 to reduce the
  // size).
  if (render_ppm_scaled("./Indiana_Jones_and_the_Last_Crusade.ppm", 50, 150,
                        0.4f) != 0) {
    fprintf(stderr, "Failed to render PPM image.\n");
  }

  // Write the final framebuffer to an output file.
  write_framebuffer_to_ppm("output.ppm");

  return 0;
}
