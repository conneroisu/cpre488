#include "platform.h"
#include "xparameters.h"
#include "xil_cache.h"
#include "xvtc.h"
#include "xaxivdma.h"

// Define VTC control register and enable bit
#define VTC_CR               (*(volatile u32 *)(XPAR_V_TC_0_BASEADDR))
#define ENABLE_VTC           0x00000001  // Enable bit for VTC

// Define VDMA base address
#define VDMA_BASEADDR        XPAR_AXI_VDMA_0_BASEADDR

// VDMA MM2S Register Offsets
#define VDMA_MM2S_CR         (*(volatile u32 *)(VDMA_BASEADDR + XAXIVDMA_CR_OFFSET))
#define VDMA_MM2S_INDEX      (*(volatile u32 *)(VDMA_BASEADDR + XAXIVDMA_HI_FRMBUF_OFFSET))
#define VDMA_MM2S_START_ADDR (*(volatile u32 *)(VDMA_BASEADDR + XAXIVDMA_MM2S_ADDR_OFFSET + XAXIVDMA_START_ADDR_OFFSET))
#define VDMA_MM2S_STRIDE     (*(volatile u32 *)(VDMA_BASEADDR + XAXIVDMA_MM2S_ADDR_OFFSET + XAXIVDMA_STRD_FRMDLY_OFFSET))
#define VDMA_MM2S_HSIZE      (*(volatile u32 *)(VDMA_BASEADDR + XAXIVDMA_MM2S_ADDR_OFFSET + XAXIVDMA_HSIZE_OFFSET))
#define VDMA_MM2S_VSIZE      (*(volatile u32 *)(VDMA_BASEADDR + XAXIVDMA_MM2S_ADDR_OFFSET + XAXIVDMA_VSIZE_OFFSET))

// Framebuffer Configuration
#define FRAMEBUFFER_ADDR     0x01000000
#define FRAME_WIDTH          640
#define FRAME_HEIGHT         480
#define BYTES_PER_PIXEL      2

u16 test_image[480][640];

int main() {
    int i, j;

    // Enable VTC module using direct register access
    VTC_CR |= ENABLE_VTC;

    // Initialize Test Image for VDMA Transfer
    for (i = 0; i < FRAME_HEIGHT; i++) {
        for (j = 0; j < FRAME_WIDTH; j++) {
            if (j < 213) {
                test_image[i][j] = 0x000F; // Red pixels
            } else if (j < 426) {
                test_image[i][j] = 0x00F0; // Green pixels
            } else {
                test_image[i][j] = 0x0F00; // Blue pixels
            }
        }
    }

    // Flush cache to ensure memory consistency
    Xil_DCacheFlush();

    /*
    // Configure VDMA using high-level function
    XAxiVdma_WriteReg(VDMA_BASEADDR, XAXIVDMA_CR_OFFSET, 0x00000003);  // Circular mode, start VDMA
    XAxiVdma_WriteReg(VDMA_BASEADDR, XAXIVDMA_HI_FRMBUF_OFFSET, 0x00000000);  // Reg_Index
    XAxiVdma_WriteReg(VDMA_BASEADDR, XAXIVDMA_MM2S_ADDR_OFFSET + XAXIVDMA_START_ADDR_OFFSET, FRAMEBUFFER_ADDR); // Framebuffer start
    XAxiVdma_WriteReg(VDMA_BASEADDR, XAXIVDMA_MM2S_ADDR_OFFSET + XAXIVDMA_STRD_FRMDLY_OFFSET, FRAME_WIDTH * BYTES_PER_PIXEL);  // Stride
    XAxiVdma_WriteReg(VDMA_BASEADDR, XAXIVDMA_MM2S_ADDR_OFFSET + XAXIVDMA_HSIZE_OFFSET, FRAME_WIDTH * BYTES_PER_PIXEL); // HSIZE
    XAxiVdma_WriteReg(VDMA_BASEADDR, XAXIVDMA_MM2S_ADDR_OFFSET + XAXIVDMA_VSIZE_OFFSET, FRAME_HEIGHT);  // VSIZE (Starts transfer)
	*/
    // Configure VDMA using direct pointer access
    VDMA_MM2S_CR = 0x00000003;  // Circular mode, enable MM2S channel
    VDMA_MM2S_INDEX = 0x00000000;  // Reg_Index
    VDMA_MM2S_START_ADDR = FRAMEBUFFER_ADDR;  // Start Address
    VDMA_MM2S_STRIDE = FRAME_WIDTH * BYTES_PER_PIXEL;  // Stride
    VDMA_MM2S_HSIZE = FRAME_WIDTH * BYTES_PER_PIXEL;  // HSIZE
    VDMA_MM2S_VSIZE = FRAME_HEIGHT;  // VSIZE (Starts transaction)

    // Cleanup
    cleanup_platform();
    return 0;
}

